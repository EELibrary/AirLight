--- ../src-base/minecraft/net/minecraft/pathfinding/PathFinder.java
+++ ../src-work/minecraft/net/minecraft/pathfinding/PathFinder.java
@@ -1,143 +1,135 @@
 package net.minecraft.pathfinding;
 
 import com.google.common.collect.Sets;
+
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import javax.annotation.Nullable;
+
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityLiving;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.world.IBlockAccess;
 
-public class PathFinder
-{
+public class PathFinder {
     private final PathHeap path = new PathHeap();
-    private final Set<PathPoint> closedSet = Sets.<PathPoint>newHashSet();
+    private final Set<PathPoint> closedSet = ConcurrentHashMap.newKeySet();
     private final PathPoint[] pathOptions = new PathPoint[32];
     private final NodeProcessor nodeProcessor;
-
-    public PathFinder(NodeProcessor processor)
-    {
+    private final Object mutex = new Object();
+    public PathFinder(NodeProcessor processor) {
         this.nodeProcessor = processor;
     }
 
     @Nullable
-    public Path findPath(IBlockAccess worldIn, EntityLiving entitylivingIn, Entity targetEntity, float maxDistance)
-    {
-        return this.findPath(worldIn, entitylivingIn, targetEntity.posX, targetEntity.getEntityBoundingBox().minY, targetEntity.posZ, maxDistance);
+    public Path findPath(IBlockAccess worldIn, EntityLiving entitylivingIn, Entity targetEntity, float maxDistance) {
+        synchronized (mutex) {
+            return this.findPath(worldIn, entitylivingIn, targetEntity.posX, targetEntity.getEntityBoundingBox().minY, targetEntity.posZ, maxDistance);
+        }
     }
 
     @Nullable
-    public Path findPath(IBlockAccess worldIn, EntityLiving entitylivingIn, BlockPos targetPos, float maxDistance)
-    {
-        return this.findPath(worldIn, entitylivingIn, (double)((float)targetPos.getX() + 0.5F), (double)((float)targetPos.getY() + 0.5F), (double)((float)targetPos.getZ() + 0.5F), maxDistance);
+    public Path findPath(IBlockAccess worldIn, EntityLiving entitylivingIn, BlockPos targetPos, float maxDistance) {
+        synchronized (mutex) {
+            return this.findPath(worldIn, entitylivingIn, (double) ((float) targetPos.getX() + 0.5F), (double) ((float) targetPos.getY() + 0.5F), (double) ((float) targetPos.getZ() + 0.5F), maxDistance);
+        }
     }
 
     @Nullable
-    private Path findPath(IBlockAccess worldIn, EntityLiving entitylivingIn, double x, double y, double z, float maxDistance)
-    {
-        this.path.clearPath();
-        this.nodeProcessor.init(worldIn, entitylivingIn);
-        PathPoint pathpoint = this.nodeProcessor.getStart();
-        PathPoint pathpoint1 = this.nodeProcessor.getPathPointToCoords(x, y, z);
-        Path path = this.findPath(pathpoint, pathpoint1, maxDistance);
-        this.nodeProcessor.postProcess();
-        return path;
+    private Path findPath(IBlockAccess worldIn, EntityLiving entitylivingIn, double x, double y, double z, float maxDistance) {
+        synchronized (mutex) {
+            this.path.clearPath();
+            this.nodeProcessor.init(worldIn, entitylivingIn);
+            PathPoint pathpoint = this.nodeProcessor.getStart();
+            PathPoint pathpoint1 = this.nodeProcessor.getPathPointToCoords(x, y, z);
+            Path path = this.findPath(pathpoint, pathpoint1, maxDistance);
+            this.nodeProcessor.postProcess();
+            return path;
+        }
     }
 
     @Nullable
-    private Path findPath(PathPoint pathFrom, PathPoint pathTo, float maxDistance)
-    {
-        pathFrom.totalPathDistance = 0.0F;
-        pathFrom.distanceToNext = pathFrom.distanceManhattan(pathTo);
-        pathFrom.distanceToTarget = pathFrom.distanceToNext;
-        this.path.clearPath();
-        this.closedSet.clear();
-        this.path.addPoint(pathFrom);
-        PathPoint pathpoint = pathFrom;
-        int i = 0;
+    private Path findPath(PathPoint pathFrom, PathPoint pathTo, float maxDistance) {
+        synchronized (mutex) {
+            pathFrom.totalPathDistance = 0.0F;
+            pathFrom.distanceToNext = pathFrom.distanceManhattan(pathTo);
+            pathFrom.distanceToTarget = pathFrom.distanceToNext;
+            this.path.clearPath();
+            this.closedSet.clear();
+            this.path.addPoint(pathFrom);
+            PathPoint pathpoint = pathFrom;
+            int i = 0;
 
-        while (!this.path.isPathEmpty())
-        {
-            ++i;
+            while (!this.path.isPathEmpty()) {
+                ++i;
 
-            if (i >= 200)
-            {
-                break;
-            }
+                if (i >= 200) {
+                    break;
+                }
 
-            PathPoint pathpoint1 = this.path.dequeue();
+                PathPoint pathpoint1 = this.path.dequeue();
 
-            if (pathpoint1.equals(pathTo))
-            {
-                pathpoint = pathTo;
-                break;
-            }
+                if (pathpoint1.equals(pathTo)) {
+                    pathpoint = pathTo;
+                    break;
+                }
 
-            if (pathpoint1.distanceManhattan(pathTo) < pathpoint.distanceManhattan(pathTo))
-            {
-                pathpoint = pathpoint1;
-            }
+                if (pathpoint1.distanceManhattan(pathTo) < pathpoint.distanceManhattan(pathTo)) {
+                    pathpoint = pathpoint1;
+                }
 
-            pathpoint1.visited = true;
-            int j = this.nodeProcessor.findPathOptions(this.pathOptions, pathpoint1, pathTo, maxDistance);
+                pathpoint1.visited = true;
+                int j = this.nodeProcessor.findPathOptions(this.pathOptions, pathpoint1, pathTo, maxDistance);
 
-            for (int k = 0; k < j; ++k)
-            {
-                PathPoint pathpoint2 = this.pathOptions[k];
-                float f = pathpoint1.distanceManhattan(pathpoint2);
-                pathpoint2.distanceFromOrigin = pathpoint1.distanceFromOrigin + f;
-                pathpoint2.cost = f + pathpoint2.costMalus;
-                float f1 = pathpoint1.totalPathDistance + pathpoint2.cost;
+                for (int k = 0; k < j; ++k) {
+                    PathPoint pathpoint2 = this.pathOptions[k];
+                    float f = pathpoint1.distanceManhattan(pathpoint2);
+                    pathpoint2.distanceFromOrigin = pathpoint1.distanceFromOrigin + f;
+                    pathpoint2.cost = f + pathpoint2.costMalus;
+                    float f1 = pathpoint1.totalPathDistance + pathpoint2.cost;
 
-                if (pathpoint2.distanceFromOrigin < maxDistance && (!pathpoint2.isAssigned() || f1 < pathpoint2.totalPathDistance))
-                {
-                    pathpoint2.previous = pathpoint1;
-                    pathpoint2.totalPathDistance = f1;
-                    pathpoint2.distanceToNext = pathpoint2.distanceManhattan(pathTo) + pathpoint2.costMalus;
+                    if (pathpoint2.distanceFromOrigin < maxDistance && (!pathpoint2.isAssigned() || f1 < pathpoint2.totalPathDistance)) {
+                        pathpoint2.previous = pathpoint1;
+                        pathpoint2.totalPathDistance = f1;
+                        pathpoint2.distanceToNext = pathpoint2.distanceManhattan(pathTo) + pathpoint2.costMalus;
 
-                    if (pathpoint2.isAssigned())
-                    {
-                        this.path.changeDistance(pathpoint2, pathpoint2.totalPathDistance + pathpoint2.distanceToNext);
+                        if (pathpoint2.isAssigned()) {
+                            this.path.changeDistance(pathpoint2, pathpoint2.totalPathDistance + pathpoint2.distanceToNext);
+                        } else {
+                            pathpoint2.distanceToTarget = pathpoint2.totalPathDistance + pathpoint2.distanceToNext;
+                            this.path.addPoint(pathpoint2);
+                        }
                     }
-                    else
-                    {
-                        pathpoint2.distanceToTarget = pathpoint2.totalPathDistance + pathpoint2.distanceToNext;
-                        this.path.addPoint(pathpoint2);
-                    }
                 }
             }
-        }
 
-        if (pathpoint == pathFrom)
-        {
-            return null;
+            if (pathpoint == pathFrom) {
+                return null;
+            } else {
+                Path path = this.createPath(pathFrom, pathpoint);
+                return path;
+            }
         }
-        else
-        {
-            Path path = this.createPath(pathFrom, pathpoint);
-            return path;
-        }
     }
 
-    private Path createPath(PathPoint start, PathPoint end)
-    {
-        int i = 1;
+    private Path createPath(PathPoint start, PathPoint end) {
+        synchronized (mutex) {
+            int i = 1;
 
-        for (PathPoint pathpoint = end; pathpoint.previous != null; pathpoint = pathpoint.previous)
-        {
-            ++i;
-        }
+            for (PathPoint pathpoint = end; pathpoint.previous != null; pathpoint = pathpoint.previous) {
+                ++i;
+            }
 
-        PathPoint[] apathpoint = new PathPoint[i];
-        PathPoint pathpoint1 = end;
-        --i;
-
-        for (apathpoint[i] = end; pathpoint1.previous != null; apathpoint[i] = pathpoint1)
-        {
-            pathpoint1 = pathpoint1.previous;
+            PathPoint[] apathpoint = new PathPoint[i];
+            PathPoint pathpoint1 = end;
             --i;
-        }
 
-        return new Path(apathpoint);
+            for (apathpoint[i] = end; pathpoint1.previous != null; apathpoint[i] = pathpoint1) {
+                pathpoint1 = pathpoint1.previous;
+                --i;
+            }
+
+            return new Path(apathpoint);
+        }
     }
 }
